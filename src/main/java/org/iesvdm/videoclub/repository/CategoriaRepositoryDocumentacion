package org.iesvdm.videoclub.repository;


import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import org.iesvdm.videoclub.domain.Categoria;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.*;
// Documentacion
//@Repository
public interface CategoriaRepositoryDocumentacion extends JpaRepository<Categoria, Long> {


    // *********** METODOS DE CONSULTAS *****************
    // EXISTEN DOS FORMAS DE EFECTUAR CONSULTAS MEDIANTE:  (JPQL- Objetos de Entidades JPA) &&  (SpringData JPA-  Tablas nativas de DDBB)

    // METODOS DE CONSULTA A IMPLEMENTAR (4)

  public List<Categoria> findCategoriaByNombreContainingIgnoreCase(String nombre);
  public List<Categoria> findCategoriaByNombreContainingIgnoreCaseOrderByNombreAsc(String nombre);
  public List<Categoria> findCategoriaByNombreContainingIgnoreCaseOrderByNombreDesc(String nombre);
  public List<Categoria> findAllCategoriaByOrderByNombreAsc();
  public List<Categoria> findAllCategoriaByOrderByNombreDesc();




    //BLOQUE METHOD @Query **"JPQL"** CON OBJETOS DE ENTIDADES JPA (
    // Notacion para asociar peticiones JPQL --o-- SQL --a un metodo pasando parametros por orden de entrada
    // de la firma del metodo  o parametrizados con mombre

    @Query(value = "select C from Categoria C where C.nombre like %:nombre%")
    public List<Categoria> queryCategoriaContainingIgnoreCase(@Param("nombre") String nombre);

    @Query(value = "select C from Categoria C where C.nombre like %:nombre% order by C.nombre asc")
    public List<Categoria> queryCategoriaContainingNombreIgnoreCaseOrderByNombreAsc(@Param("nombre") String nombre);

    @Query(value = "select C from Categoria C where C.nombre like ?1 order by C.nombre asc")
    public List<Categoria> queryCategoriaContainingNombreIgnoreCaseOrderByNombreDesc(String nombre);

    @Query(value = "select C from Categoria C order by C.nombre asc")
    public List<Categoria> queryAllCategoriaByNombreByOrderByAsc();

    @Query(value = "select C from Categoria C order by C.nombre desc")
    public List<Categoria> queryAllCategoriaByNombreByOrderByDesc();


    //BLOQUE DE METODOS @QUERRY CON SQL NATIVO BASADO EN LAS TABLAS.
    //@Query nativeQuery = true, es decir, SQL con **"JPA"**:
    // Se Parametrizan con el nombre del parametro:  (%:nombre%)

    @Query(value = "select * from categoria where nombre like nombre", nativeQuery = true)
    public List<Categoria> queryCategoriaByNombreContainingIgnoreCase(@Param("nombre") String nombre);

    @Query(value = "select * from Categoria C where C.nombre like nombre order by C.nombre asc", nativeQuery = true)
    public List<Categoria> queryCategoriaByNombreContainingIgnoreCaseOrderByNombreAsc(@Param("nombre") String nombre);

    // Parametrizada por  Parametros de entrada posicionales:  ?1
    @Query(value = "select * from Categoria C where C.nombre like ? order by C.nombre asc", nativeQuery = true)
    public List<Categoria> queryCategoriaByNombreContainingIgnoreCaseOrderByNombreDesc(String nombre);

    @Query(value = "select * from Categoria C order by C.nombre asc", nativeQuery = true)
    public List<Categoria> queryAllCategoriaByOrderByNombreAsc();

    @Query(value = "select * from Categoria C order by C.nombre desc", nativeQuery = true)
    public List<Categoria> queryAllCategoriaByOrderByNombreDesc();



  @PersistenceContext
  private EntityManager em;


  //BLOQUE METHOD @Query JPQL CON OBJETOS DE ENTIDADES JPA
  //Notación para asociar peticiones JPQL o SQL a un método pasando parámetros por orden de entrada
  // de la firma del método o parametrizados con nombre
  public List<Categoria> queryCategoriaCustomJPQL(Optional<String> buscarOptional, Optional<String>  ordenarOptional) {
    StringBuilder queryBuilder = new StringBuilder("select C from categoria");
    if (buscarOptional.isPresent()){
      queryBuilder.append(" ").append("where C.nombre like: nombre");
    }
    if (ordenarOptional.isPresent()){
      if(buscarOptional.isPresent() && "asc".equalsIgnoreCase(buscarOptional.get())){
        queryBuilder.append(" ").append("order by C.nombre ASC");
      }else if(buscarOptional.isPresent() && "desc".equalsIgnoreCase(buscarOptional.get())) {
        queryBuilder.append(" ").append("order by C.nombre desc");
      }
    }
    jakarta.persistence.Query query = em.createQuery(queryBuilder.toString());
    if (buscarOptional.isPresent()){
      query.setParameter("nombre", "%"+buscarOptional.get()+"%");
    }
    return query.getResultList();
  }





  //BLOQUE DE MÉTODOS @QUERY CON "SQL" NATIVO BASADO EN LAS TABLAS.
  //@Query nativeQuery = true, es decir, SQL:
  // Se Parametrizan con el nombre del parámetro:  (%:nombre%)
  public List<Categoria> queryCategoriaCustomJPA(Optional<String> buscarOptional,Optional<String>  ordenarOptional ) {
    StringBuilder queryBuilder = new StringBuilder("select * from categoria");
    if (buscarOptional.isPresent()){
      queryBuilder.append(" ").append("where nombre like: nombre");
    }
    if (ordenarOptional.isPresent()){
      if(buscarOptional.isPresent() && "asc".equalsIgnoreCase(buscarOptional.get())){
        queryBuilder.append(" ").append("order by nombre ASC");
      }else if(buscarOptional.isPresent() && "desc".equalsIgnoreCase(buscarOptional.get())) {
        queryBuilder.append(" ").append("order by nombre desc");
      }
    }
    jakarta.persistence.Query query = em.createNativeQuery(queryBuilder.toString(),Categoria.class);
    if (buscarOptional.isPresent()){
      query.setParameter("nombre", "%"+buscarOptional.get()+"%");
    }
    return query.getResultList();
  }
}